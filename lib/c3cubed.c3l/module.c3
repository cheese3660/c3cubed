module c3cubed;
import std::collections::list;
def DataMemberList = List(<Data*>);
def TypeList = List(<Type*>);
def FunctionList = List(<Function*>);
def StringList = List(<DString>);

struct Module {
    
    DString header_comment; 
    TypeList types;
    FunctionList functions;
    DataMemberList data;



    // Internal information
    Allocator allocator;
    StringList interned_names;
}


/*
 * @require !self.allocator "Module has already been initialized!"
 */
fn void Module.initialize(&self, Allocator allocator = allocator::heap()) {
    self.allocator = allocator::heap();
    self.header_comment = null;
    self.types.new_init(BLOCK_CAPACITY,allocator);
    self.functions.new_init(BLOCK_CAPACITY,allocator);
    self.data.new_init(BLOCK_CAPACITY,allocator);
    self.interned_names.new_init(TYPE_CAPACITY,allocator);
}


fn void Module.set_header(&self, String header = "") {
    if (!self.allocator) {
        self.initialize();
    }
    self.header_comment = dstring::new(header,self.allocator);
}

fn Identifier Module.import_ident(&self, String name, IdentifierType type = GLOBAL, bool intern=true) {
    if (!self.allocator) {
        self.initialize();
    }
    if (intern) {
        foreach (DString str : self.interned_names) {
            if (str.str_view() == name) {
                return Identifier {
                    .type = type,
                    .identifier_name = str.str_view()
                };
            }
        }
    }
    DString to_add = dstring::new(name,self.allocator);
    self.interned_names.push(to_add);
    return Identifier {
        .type = type,
        .identifier_name = to_add.str_view()
    };
}

fn DataMember Module.import_string(&self, String value, TypeReference type=TYPE_BYTE, bool intern=true) {
    if (!self.allocator) {
        self.initialize();
    }
    if (intern) {
        foreach (DString str : self.interned_names) {
            if (str.str_view() == value) {
                return DataMember {
                    .type = STRING,
                    .datatype = type,
                    .str = str.str_view()
                };
            }
        }
    }
    DString to_add = dstring::new(value,self.allocator);
    self.interned_names.push(to_add);
    return DataMember {
        .type = STRING,
        .datatype = type,
        .str = to_add.str_view()
    };
}

fn Type* Module.register_type(&self, String name) {
    if (!self.allocator) {
        self.initialize();
    }
    Type* ptr = allocator::alloc(self.allocator, Type);
    *ptr = {};
    ptr.initialize(self, name);
    self.types.push(ptr);
    return ptr;
}

fn Function* Module.register_function(&self, String name) {
    if (!self.allocator) {
        self.initialize();
    }
    Function* ptr = allocator::alloc(self.allocator, Function);
    *ptr = {};
    ptr.initialize(self, name);
    self.functions.push(ptr);
    return ptr;
}

fn Data* Module.register_data(&self, String name) {
    if (!self.allocator) {
        self.initialize();
    }
    Data* ptr = allocator::alloc(self.allocator, Data);
    *ptr = {};
    ptr.initialize(self, name);
    self.data.push(ptr);
    return ptr;
}

fn Linkage Module.get_section(&self, String name, String flags="", bool intern=true) {
    if (!self.allocator) {
        self.initialize();
    }
    String name_view;
    bool found_name;
    bool has_flags = flags != "";
    if (intern) {
        foreach (DString str : self.interned_names) {
            if (str.str_view() == name) {
                name_view = str.str_view();
                found_name = true;
                break;
            }
        }
    }
    if (!found_name) {
        DString to_add = dstring::new(name,self.allocator);
        self.interned_names.push(to_add);
        name_view = to_add.str_view();
    }
    String flags_view;
    if (has_flags) {
        bool found_flags;
        if (intern) {
            foreach (DString str : self.interned_names) {
                if (str.str_view() == flags) {
                    flags_view = str.str_view();
                    found_flags = true;
                    break;
                }
            }
        }
        if (!found_name) {
            DString to_add = dstring::new(flags,self.allocator);
            self.interned_names.push(to_add);
            flags_view = to_add.str_view();
        }
    }
    if (has_flags) {
        return {
            .type = SECTION_FLAGS,
            .section = name_view,
            .flags = flags_view
        };
    } else {
        return {
            .type = SECTION,
            .section = name_view
        };
    }
}


// Export a QBE module to a DString
fn DString Module.write(&self) {
    DString result = dstring::new();
    result.append("# Generated by c3-cubed\n\n");
    if (self.header_comment) {
        append_header(&result, self.header_comment.str_view());
        result.append('\n');
    }
    @pool() {
        foreach (Type* type : self.types) {
            result.appendf("%s\n",type.get_string());
        }
        foreach (Function* function : self.functions) {
            result.appendf("%s\n",function.get_string());
        }
        foreach (Data* data : self.data) {
            result.appendf("%s\n",data.get_string());
        }
    };
    return result;
}

fn void Module.free(&self) {
    if (!self.allocator) {
        return;
    }
    self.header_comment.free();
    foreach (Type* type : self.types) {
        type.free();
        allocator::free(self.allocator,type);
    }
    foreach (Function* function : self.functions) {
        function.free();
        allocator::free(self.allocator,function);
    }
    foreach (Data* data : self.data) {
        data.free();
        allocator::free(self.allocator,data);
    }
    foreach (DString str : self.interned_names) {
        str.free();
    }
}